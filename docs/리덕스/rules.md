---
layout: page
title: 리덕스의 3가지 규칙
parent: 리덕스
nav_order: 2
has_children: false
permalink: /redux/rules
---

# 리덕스의 3가지 규칙


리덕스를 프로젝트에서 사용하게 될 때 알아두고, 꼭 지켜야 할 3가지 규칙이 있다.

## 1\. 하나의 애플리케이션 안에는 하나의 스토어가 있다.  
하나의 애플리케이션에서는 단 한개의 스토어를 만들어서 사용한다. 여러개의 스토어를 사용하는 것은 사실 가능하긴 하지만 권장되지는 않는다.  
특정 업데이트가 너무 빈번하게 일어나거나, 애플리케이션의 특정 부분을 완전히 분리시키게 될 때 여러개의 스토어를 만들 수도 있다. 하지만 그렇게 되면 개발도구를 활용하지 못하게 된다.

## 2\. 상태는 읽기전용이다.  
리액트에서는 `state`를 업데이트 해야 할 때 `setState`를 사용하고, 배열을 업데이트 해야할 때는 배열 자체에 push를 직접하지 않고 `concat`같은 함수를 사용한다. 기존의 배열은 수정하지 않고 새로운 배열을 만들어서 교체하는 방식으로 업데이트를 한다.  
엄청 깊은 구조로 되어있는 개체를 업데이트를 할 때도 마찬가지로, 기존의 객체는 건드리지 않고 `Object.assign`을 사용하거나 `spread 연산자(...)`를 사용하여 업데이트하곤 한다.  

리덕스에서도 마찬가지다. 기존의 상태는 건들이지 않고 새로운 상태를 생성하고 업데이트 해주는 방식으로 해주면, 나중에 개발자 도구를 통해 뒤로 돌릴 수도 있고 앞으로 돌릴 수도 있다.  

리덕스에서 불변성을 유지해야 하는 이유는 내부적으로 데이터가 변경되는 것을 감지하기 위해 `shallow equality`검사를 하기 때문이다.  
이를 통해 객체의 변화를 감지할 때 객체의 깊숙한 부분까지 비교를 하는 것이 아니라 겉핡기 식으로 비교를 하여 성능을 유지할 수 있는 것이다.  

이번 리덕스를 배우면서 `Immutable.js` 혹은 `Immer.js`를 사용하여 불변성을 유지하며 상태를 관리하는 방법에 대해 다뤄볼 것이다. 불변성과 Immutable.js가 익숙하지 않다면 [리액트의 불변함, 컴포넌트에서 `Immutable.js`사용하기](https://velopert.com/3486)를 읽어보자.

## 3\. 변화를 일으키는 함수인 리듀서는 순수한 함수여야 한다.  
다음 사항을 숙지하자.  
- 리듀서함수는 이전 상태와 액션 객체를 파라미터로 받는다.
- 이전의 상태는 절대 건들이지 않고, 변화를 일으킨 새로운 상태 객체를 만들어서 반환한다.
- 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과값을 반환해야 한다.

동일한 인풋이라면 언제나 동일한 아웃풋이 있어야 한다. 그러넫 일부 로직들 중에서는 실행할 때 마다 다른 결과값이 나올 수 있다. `new Date()`를 사용한다던지..  
그러한 작업은 결코 순수하지 못한 작업이므로 리듀서함수의 바깥에서 처리해줘야 한다.  
이러한 작업을 하기 위해 리덕스 미들웨어를 사용하곤 한다. 이에 대해선 나중에 포스트로 따로 정리하겠다.
