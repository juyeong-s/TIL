---
layout: page
title: 클로저의 활용
parent: 자바스크립트
nav_order: 15
has_children: false
permalink: /js/closure-2/
---

# 클로저의 활용

**클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.** 다시 말해, **상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용**하기 위해 사용한다.

함수가 호출될 때마다 호출된 횟수를 누적하여 출력하는 카운터를 만들어보자. 이 예제에서 호출된 횟수가 바로 안전하게 변경하고 유지해야할 상태이다.

![code](https://user-images.githubusercontent.com/63364990/162769297-d9af5b73-7c18-475e-a62a-a17efb82b9c2.png)

위 코드는 잘 동작하지만 오류를 발생시킬 가능성을 내포하고 있다. 그 이유는 위 예제가 바르게 동작하려면 다음의 전제 조건이 지켜져야 하기 때문이다.  
1\. 카운트 상태는 `increase`함수가 호출되기 전까지 변경되지 않고 유지되어야 한다.  
2\. 이를 위해 카운트 상태는 `increase`함수만이 변경할 수 있어야 한다.

하지만 카운트 상태는 전역 변수를 통해 관리되고 있기 때문에 언제든지 누구나 접근할 수 있다. 이는 의도치 않게 상태가 변경될 수 있다는 것을 의미한다.

따라서, 카운트 상태를 안전하게 변경하고 유지하기 위해서는 increase 함수만이 접근할 수 있도록 전역변수 num을 지역변수로 바꾸어야 하는데,,! ⬇️

![code](https://user-images.githubusercontent.com/63364990/162771390-8cf1bdc5-0fc4-42a1-89a4-eaca8d6f6ae5.png)

또 문제가 있다 당연히 ..ㅎ increase함수가 호출될 때마다 카운트 변수가 초기화 되기 때문에 올바른 동작을 하지 못하고 계속 1만 출력할 것이다. 이때 클로저를 사용할 수 있다.

![code](https://user-images.githubusercontent.com/63364990/162778170-70d0f75e-8ecf-403a-a9bb-4a36c6640591.png)

위 코드가 실행되면 `즉시 실행 함수`가 호출되고, 즉시 실행 함수가 반환한 `return function() {...}`이 `increase` 변수에 할당될 것이다. `increase` 변수에 할당된 함수는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하는 `클로저`이다.  
`increase` 함수는 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하고 있으므로 num변수에 접근할 수 있다.

즉시 실행 함수는 한번만 호출되므로 `increase`가 호출될 때마다 num변수가 재차 초기화 되지 않는다. 또한, num변수는 외부에서 직접 접근할 수 없는 은닉된 `private`변수이므로 전역 변수를 사용했을 때의 문제점은 없다.

**이처럼 클로저는 상태가 의도치 않게 변경되지 않도록 은닉하고, 특정함수에만 상태 변경을 허용하여 상태를 안전하게 보호한다.**
