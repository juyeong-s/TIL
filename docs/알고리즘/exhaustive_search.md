---
layout: page
title: 완전탐색(Exhaustive Search)
parent: 알고리즘
nav_order: 2
has_children: false
permalink: /algo/es
---

# 완전탐색(Exhaustive Search)

완전탐색은 가능한 모든 경우의 수를 다 체크해서 정답을 찾는 방법이다. 즉, 무식하게 가능한 거 다 해보겠다는 의미이다.

완전탐색은 무식하게 다 해본다는 의미로 "Brute Force"라고도 불린다. 직관적이라 이해하기 쉽고 가장 기초적인 방법이다.

완전탐색에는 다음 2가지 규칙이 필요하다.  
1. 문제를 해결할 수 있는가?
2. 효율적으로 동작하는가?

위 2가지 규칙에서 1번은 딩연히 만족될 수 있으나 2번 때문에 완전탐색을 사용하는데 제한이 따른다.

예를 들어, 백준의 [1912번](https://www.acmicpc.net/problem/1912) 문제를 보자.  
다이나믹 프로그래밍으로 문제를 풀면 O(N)으로 해결할 수 있지만 완전탐색을 적용한다면 2중 반복문에 의해 O(N^2)의 시간복잡도를 갖게 된다.

따라서, 완전탐색을 사용할 때는 그 문제에 대한 파악이 중요하다.

## 완전탐색 기법 활용하기

완전탐색 자체가 알고리즘이 아니기 때문에 이 방법을 이용하기 위해서는 아래의 여러가지 알고리즘 기법이 사용된다.  
- 단순 Brute-Force
- 비트마스크
- 재귀 함수
- 순열
- BFS/DFS

기본적으로 완전 탐색은 N의 크기가 작을 때 이용된다.

## 1\. 단순 Brute-Force

단순히 for문과 if문 등으로 모든 case를 만들어 답을 구하는 방법이다. 아주 기초적인 문제나 전체 풀이의 일부분으로 이용한다.  
당연히 대회나 코테에서는 이 방법만을 이용한 문제는 거의 나오지 않는다고 한다.

## 2\. 비트마스크(Bitmask)

2진수를 이용하는 방식이다. 완전 탐색에서 비트마스크는 문제에서 나올 수 있는 모든 경우의 수가 **각각의 원소가 포함되거나**, **포함되지 않는** 두 가지 선택으로 구성되는 경우에 유용하게 사용이 가능하다.  

간단한 예시로 원소가 5개인 집합의 모든 부분집합을 구하는 경우를 생각해보자. 

어떤 집합의 부분집합은 집합의 각 원소가 해당 부분집합에 포함되거나, 포함되지 않는 두 가지 경우만 존재한다. 

따라서 5자리 이진수 (십진수로 0부터 ~ 31까지 나타낼 수 있음)를 이용하여 각 원소의 포함 여부를 체크할 수 있다.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FMICx8%2FbtqIl92dgLq%2FgLKTsc0ofKianC1ZQnQlNk%2Fimg.png)

10진수 1은 2진수로 `00001`이고 마지막 원소만 포함된다는 의미로 1이다. 여기서 10 원소가 포함되어 있다는 것을 알 수 있다.

10진수 31은 2진수로 `11111`이고 모든 원소가 포함된다는 의미로 보면 된다.

## 3\. 재귀 함수

재귀는 말 그대로 자기 자신을 호출한다는 의미이다.  
예를 들어, 총 4개의 숫자 중에 2개를 선택하는 경우를 모두 출력한다고 가정해보자. 1~4까지 숫자가 있고 2개를 중복 없이 선택하는 모든 경우의 수를 출력하고자 한다면 다음과 같이 반복문으로 표현할 수 있다.  

```
for i from 1 to 4
    chose i
    for j from i+1 to 4
        chose j
        print i j
```

손 쉽게 2중 반복문으로 해결하였다. 그런데 만약 숫자 N개의 숫자 중 M개를 고르는 경우라고 할 때, N과 M이 매우 큰 숫자라면 어떨까? 반복문을 수없이 쓸 수는 없을 것이다.

이를 재귀함수로 활용할 수 있다. 아래와 같이, 1~100의 숫자 중 5개를 선택하는 경우를 코드로 작성해보자.

```
function main(){
    const limit = 100;
    const n = 5;
    const chosen = [];
    solve(0, 0);

    function solve(curr, cnt){
        if(cnt === n){
            for(const number of chosen){
                console.log(number);
            }
            return;
        }

        for(let i = curr+1; i <= limit; i++){
            chosen[cnt] = i;
            solve(chosen, curr, cnt+1);
        }
    }
}
```


보면,  Dynamic Programming과도 매우 흡사해 보인다. 하지만, 완전 탐색의 재귀와 DP의 차이점은, DP는 작은 문제가 큰 문제와 동일한 구조를 가져 큰 문제의 답을 구할 시 작은 문제의 결과를 기억한 뒤 그대로 사용하여 수행 속도를 빠르게 한다는 것이다.

그에 반해 완전 탐색은 고 작은 문제의 구조가 다를 수 있다. 이전 결과를 반드시 기억하는 것이 아니라 해결 가능한 방법을 모두 탐색한다는 차이가 있다.

## 4\. 순열

순열은 임의의 수열이 있을 때, 그것을 다른 순서로 연산하는 방법을 의미한다.

즉, 순서가 중요하다! 수열에서 숫자 `[1, 2, 3]`이 있다면, 이것을 `[1, 2, 3]`으로 보는 순서와 `[3, 2, 1]`로 보는 순서가 차이가 있음이 중요한 경우에 적용할 수 있다.

## 5\. BFS/DFS

BFS/DFS의 대표적인 유형으로 길 찾기 문제가 있다. 단순히 길을 찾는 문제라면 BFS/DFS만 이용하면 되지만, 주어진 도로에 장애물이 있거나, 목적지를 추가하는 등 추가적인 작업이 필요한 경우에 이를 완전 탐색으로 해결하고 나서, BFS/DFS를 이용하기도 한다.
