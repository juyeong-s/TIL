---
layout: page
title: 냅색(knapsack)
parent: 알고리즘
nav_order: 3
has_children: false
permalink: /algo/knapsack
---

# 냅색(배낭, knapsack) 알고리즘

냅색 알고리즘은 유명한 DP문제 중 하나이다.  
냅색은 두가지로 나뉜다.  
- 물건을 쪼갤 수 있는 배낭문제(Fraction Knapsack)
- 물건을 쪼갤 수 없는 배낭문제(0-1 Knapsack)  


# Fraction Knapsack(분할가능 배낭)  

**짐을 쪼갤 수 있는 경우의 배낭문제**(무게가 소수일 수 있는 경우)
- 가치가 큰 물건부터 담고, 남은 무게만큼 물건을 쪼개는 방식으로, `그리디 알고리즘`으로 해결할 수 있다.
물건의 가격을 무게로 나누어, 무게 대비 가격이 비싼 순서로 물건을 정렬해서 넣으면 쉽게 해결할 수 있다. -> *남은 배낭이 감당할 수 있는 무게*보다 *물건의 무게*가 많이 나가면 잘라서 넣으면 된다! (그리디로 해결가능)

## 알고리즘 과정  

1. 각 항목의 `가치/무게` *비율*을 계산하고, 이 비율을 기준으로 항목을 정렬한다.
2. 가장 가치가 높은 비율 항목부터 가방에 담는다.
3. 만약, 현재 가방의 용량이 담을 항목의 무게보다 크다면, 모두 선택하여 항목의 가치를 모두 더한다.
4. 만약, 현재 가방의 용량이 담을 항목의 무게보다 작다면, 담을 수 있는 용량만큼 쪼개서 담고 가치는 *비율*만큼 계산하여 더해준 후, 루프를 빠져나온다.


# 0-1 Knapsack  

**짐을 쪼갤 수 없는 경우의 배낭문제**(무게가 0이상의 정수만)  
물건을 자를 수 없기 때문에 물건, 물건의 무게, 가격, 배낭의 남은 용량을 모두 고려해야 한다. -> 짐을 쪼갤 수 없기 때문에 짐 1개를 가지던지 버리던지 해야한다. (DP로 해결가능)

## 예시

- 배낭의 최대 용량 W = 50  

| 짐(item) | 무게(weight) | 가치(value) |
| --- | --- | --- |
| a | 10 | 60 |
| b | 20 | 100 |
| c | 30 | 120 |

배낭에 무게 50kg까지 담을 수 있다.  
b = 20kg, c = 30kg을 가져갈 때, 최대 50kg이 되고 가치의 합이 220으로 최대가 된다.  

## 알고리즘 과정  

물건은 (무게, 가치)로 나타내겠다.

- **물건 : (2,3), (3, 4), (4, 5), (5, 6)**
- **가방의 최대 무게 : 5**

- 2차원 배열을 만들고, 각 행 i는 물건의 번호, j열은 최대 무게를 가르키도록 한다.
- 새로 생긴 원소는 📍로 표시하겠다.

| | 0 | 1 | 2| 3 | 4 | 5 |
| - | - | - | - | - | - | - |
| 0 |  |  |  |  |  |  |
| 1 (2, 3) |  |  |  |  |  |  |
| 2 (3, 4) |  |  |  |  |  |  |
| 3 (4, 5) |  |  |  |  |  |  |
| 4 (5, 6) |  |  |  |  |  |  |

- 최대 무게가 0일 때, 물건이 없을 때는 가방에 넣을 수 있는 최대 가치는 당연히 0이다.  
따라서 첫 행과 첫 열은 0으로 채운다.

| | 0 | 1 | 2| 3 | 4 | 5 |
| - | - | - | - | - | - | - |
| 0 | 📍0 | 📍0 | 📍0 | 📍0 | 📍0 | 📍0 |
| 1 (2, 3) | 📍0 |  |  |  |  |  |
| 2 (3, 4) | 📍0 |  |  |  |  |  |
| 3 (4, 5) | 📍0 |  |  |  |  |  |
| 4 (5, 6) | 📍0 |  |  |  |  |  |


- 첫 물건을 보면, 무게가 2, 가치가 3이다. 이 물건을 최대 무개가 1일 때는 넣을 수 없기 때문에 (1, 1)에는 0을 넣어준다.

| | 0 | 1 | 2| 3 | 4 | 5 |
| - | - | - | - | - | - | - |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 (2, 3) | 0 | 📍0 |  |  |  |  |
| 2 (3, 4) | 0 |  |  |  |  |  |
| 3 (4, 5) | 0 |  |  |  |  |  |
| 4 (5, 6) | 0 |  |  |  |  |  |


- 최대 무개가 2일 때는 1번 물건의 무게가 2이기 때문에 딱 맞아 넣을 수 있다. 물건을 넣게되면 최대 가치가 3이 된다. (2, 1)에는 1번 물건의 가치 3을 넣어준다.

| | 0 | 1 | 2| 3 | 4 | 5 |
| - | - | - | - | - | - | - |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 (2, 3) | 0 | 0 | 📍3 |  |  |  |
| 2 (3, 4) | 0 |  |  |  |  |  |
| 3 (4, 5) | 0 |  |  |  |  |  |
| 4 (5, 6) | 0 |  |  |  |  |  |


- 첫번째 물건의 무게는 2이기 때문에, 최대 무게인 3, 4, 5에서도 하나씩 넣을 수 있어 가치 3을 넣어주면 된다.

| | 0 | 1 | 2| 3 | 4 | 5 |
| - | - | - | - | - | - | - |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 (2, 3) | 0 | 0 | 3 | 📍3 | 📍3 | 📍3 |
| 2 (3, 4) | 0 |  |  |  |  |  |
| 3 (4, 5) | 0 |  |  |  |  |  |
| 4 (5, 6) | 0 |  |  |  |  |  |


- 다음 물건으로 넘어가보자. 2번째 물건은 무게 3, 가치 4이다.
일단 무게가 3이기 때문에 최대무게가 3이 되기 전까지는 물건을 넣을 수 없으므로 0으로 채워준다.  
따라서, 3미만의 무게에는 모두 1번째 물건만 넣은 상태로 유지한다.

| | 0 | 1 | 2| 3 | 4 | 5 |
| - | - | - | - | - | - | - |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 (2, 3) | 0 | 0 | 3 | 3 | 3 | 3 |
| 2 (3, 4) | 0 | 📍0 | 📍3 |  |  |  |
| 3 (4, 5) | 0 |  |  |  |  |  |
| 4 (5, 6) | 0 |  |  |  |  |  |


- 이제 최대 무게가 3이 되었을 때는 2가지 선택지가 있다.  
    - 2번째 물건을 넣는 경우,
        * 이 물건을 넣을 경우 최대 무게를 초과하게 된다. 왜냐하면 이미 첫번째 물건 무게인 2가 들어있기 때문이다.
        따라서, 이 물건을 넣으려면 첫번째 물건을 빼고 넣어줘야 한다.
        그럼 가치는 두번째 물건인 4가 된다.
    - 2번째 물건을 넣지 않는 경우,
        * 가방 안에 첫번째 물건이 들어있으므로 현재 가치는 그대로 3이 된다.

- 우리는 가방 안의 가치를 최대로 하고 싶기 때문에 2번째 물건을 넣어 가치를 4로 만들 것이다.

| | 0 | 1 | 2| 3 | 4 | 5 |
| - | - | - | - | - | - | - |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 (2, 3) | 0 | 0 | 3 | 3 | 3 | 3 |
| 2 (3, 4) | 0 | 0 | 3 | 📍4 |  |  |
| 3 (4, 5) | 0 |  |  |  |  |  |
| 4 (5, 6) | 0 |  |  |  |  |  |

- 가방의 최대 무게가 4일 때, 2번째 물건을 그냥 넣는 것이 이득이다.
- 가방의 최대 무게가 5일 때는, 1번 물건(2)에 2번 물건(3)을 넣어도 최대 무게 5를 초과하지 않는다. 따라서, 두 물건 모두 넣는다.

| | 0 | 1 | 2| 3 | 4 | 5 |
| - | - | - | - | - | - | - |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 (2, 3) | 0 | 0 | 3 | 3 | 3 | 3 |
| 2 (3, 4) | 0 | 0 | 3 | 4 | 📍4 | 📍7 |
| 3 (4, 5) | 0 |  |  |  |  |  |
| 4 (5, 6) | 0 |  |  |  |  |  |

- 이런 식으로 쭉 진행해보면, 아래와 같은 2차원 배열을 얻을 수 있다.
- 최대 무게 5에서 최대가치가 7이 된다는 걸 알 수 있다.

| | 0 | 1 | 2| 3 | 4 | 5 |
| - | - | - | - | - | - | - |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 (2, 3) | 0 | 0 | 3 | 3 | 3 | 3 |
| 2 (3, 4) | 0 | 0 | 3 | 4 | 4 | 7 |
| 3 (4, 5) | 0 | 📍0 | 📍3 | 📍4 | 📍5 | 📍7 |
| 4 (5, 6) | 0 | 📍0 | 📍3 | 📍4 | 📍5 | 📍7 |

## 소스코드 - 자바스크립트  

```
// rows: 각 item을 나타냄
// cols: 현재 가방의 최대한도가 col이라면 얼마까지 넣을 수 있는지

function knapSack(W, weight, value, N) {
  const memo = Array.from({ length: N + 1 }, () => Array(W + 1).fill(0));

  for (let n = 1; n < N + 1; n++) {
    for (let w = 1; w < W + 1; w++) {
      memo[n][w] = weight[n - 1] > w ?  // 현재 item의 무게(weight[n - 1]) 가 행(col)인 w 최대 한도보다 큰 경우
            memo[n - 1][w] // 이전까지 누적된 value 입력
          : // 현재 item 무게(weight[n - 1]) 가 행(col)인 w 최대 한도보다 작은 경우
            Math.max(memo[n - 1][w - weight[n - 1]] + value[n - 1], memo[n - 1][w]);    // (현재 무게 빼고 누적된 value + 현재 value)와 (이전까지 누적된 value)와 비교
    }
  }
  return memo[N][W];    // 마지막 item까지 판단하고, 최대 weight 한도에서 가질 수 있는 최대 value
}
```
